# 死锁

## 一、死锁概述

### 1、什么是死锁

死锁就是两个及两个以上的进程，互相想要获得对方已经拥有的资源，导致各进程都被阻塞，无法向前推进的现象。

对不可剥夺资源的不合理分配，可能会导致死锁。

——》区别于饥饿现象：死锁发生的时候，一定是至少有两个进程同时发生了死锁。饥饿的话可能只有一个，而且饥饿可能会自发得到解决。当然这两个概念的发生机制也不一样，自己可以思考理解一下。

### 2、死锁产生的必要条件

```markdown
1、互斥条件 —— 对必须互斥使用的资源的争抢才会导致死锁
2、不剥夺条件 —— 进程保持的资源只能主动释放，不可强行剥夺
3、请求和保持条件 —— 保持已有的资源的同时，请求别的资源
4、循环等待条件 —— 存在一种进程资源的循环等待链 （循环等待未必死锁，死锁一定会有循环等待）
```

## 二、死锁的处理机制

### 1、不允许死锁发生

#### 1.1 预防死锁（静态策略）

```markdown
1、破坏互斥条件
	将互斥的资源改成共享的资源，当然这需要亿点点技术支持
	——缺点：可行性不高，很多时候无法破坏互斥条件
2、破坏不剥夺条件
	a.别的进程请求你的资源，你必须主动释放自己已经占有的资源。
	b.别的进程请求你的资源，操作系统强行剥夺你拥有的资源
	——缺点：实现复杂；剥夺资源可能导致部分资源失效；反复申请和释放导致系统开销大；可能导致饥饿
3、破坏请求和保持条件
	运行前就分配好所有需要的资源，之后一直保持
	——缺点：资源利用率低；可能导致饥饿
4、破坏循环等待条件
	给资源编号，必须按照编号从小到大的顺序申请资源
	——缺点：不方便添加新设备；会导致资源浪费；用户编程麻烦
```

#### 1.2 避免死锁（动态策略）

这里就是用到了大名鼎鼎的银行家算法，自己思考回忆吧

### 2、允许死锁发生

#### 2.1 死锁的检测

##### 1、如何检测？

——》使用一种数据结构，称作资源分配图，拥有：两种节点（进程节点和资源节点，节点个数就是进程或者资源的个数）和两种边（进程——》资源 的请求边， 资源——》进程 的分配边）。

##### 2、死锁检测算法

依次消除与不阻塞进程（申请的资源数还足够的进程）相连的边，直到无边可消

——死锁定理：若资源分配图是不可完全简化的，说明发生了死锁

#### 2.2 死锁的解除

```markdown
1、资源剥夺法
	挂起某些死锁进程到外存上，并抢占它的资源用于分配给其他进程。但是可能被挂起的进程出现饥饿现象
2、撤销进程法（终止进程法）
	强制撤销部分或者全部死锁进程，并剥夺这些进程拥有的资源。但是代价太大了
3、进程回退法
	让一个或多个死锁进程回退到足以避免死锁的地步，这就要求系统记录进程的历史信息，设置还原点
```

