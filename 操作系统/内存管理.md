# 内存管理

## 一、概述

先让我们看看内存管理的主要框架，即这章我们要学习什么。

首先明确一下，内存是什么，内存能干什么

```markdown
1、内存是CPU能直接寻址的存储空间，但是存储是暂时的，断电后所有储存内容全部丢掉。
2、程序必须要先放到内存上才能被CPU处理。
	
	wiki上的比喻很形象：好比在一个书房里，存放书籍的书架和书柜相当于电脑的外部存储器，而我们工作的办公桌就是内存。通常我们把要永久保存的、大量的数据储存在外部存储器上，而把一些临时的或少量的数据和程序放在内存上。
```

```markdown
——ps：4GB内存 《=》 可存放 4 * 2 ^ 30 个字节 《=》 2 ^ 32 个存储单元 《=》 2 ^ 32 个地址才可以标识 《=》 地址长度为32
	这里说明一下：1kb = 1024个字节 1MB = 1024个kb 1GB = 1024MB
	所以4GB = 4 * 1024 * 1024 * 1024字节 = 4 * 2 ^ 30字节
	
	基础单位：位/比特 ——》 字节 ——》 字 （但是字长直接指的是拥有的比特长度）
	1、数据存储是以“字节”为单位，数据传输以“位”（比特）为单位，1个位代表一个0或者1，每8个位组成一个字节，是最小一级的信息单位。
	2、在计算机中，一串数码作为一个整体来处理或运算的，称为一个计算机字，简称字。字通常分为若干个字节（每个字节一般是8位）。在存储器中，通常每个单元存储一个字。因此每个字都是可以寻址的。字的长度用位数来表示。
	3、计算机的每个字所包含的位数称为字长，计算的字长是指它一次可处理的二进制数字的数目。一般地，大型计算机的字长为32-64位，小型计算机为12-32位，而微型计算机为4-16位。字长是衡量计算机性能的一个重要因素。
```

主要内容，即内存管理要实现的功能：

```markdown
内存的分配与回收（引入——内部碎片（插入内存后产生的） 和 外部碎片（压根插不进内存））
	连续分配
		单一连续分配
		固定分区分配
		动态分区分配
	非连续分配
		分页存储管理
			基本分页存储管理
				要掌握的内容：
					概念：页、页框、块、地址结构、页表
					基本地址变换机构
					具有快表的地址变换机构
					两级页表
			请求分页存储管理（引入虚拟存储技术）
		分段存储管理
		段页存储管理
内存空间的扩充
	覆盖技术
	交换技术
	虚拟存储技术
地址转换（穿插全文）
存储保护
```

## 二、内存管理的基本原理和要求

### 1、程序的装入和链接

创建进程首先要将程序和数据装入内存，那么怎么将用户源程序装入内存呢？这就是涉及到了三个步骤：

```markdown
1、编译
	将用户源代码编译成若干目标模块
2、链接
	将编译后得到的一组目标模块以及所需的库函数链接在一起，形成一个完整的装入模块
3、装入
	装入程序将装入模块装入内存运行
```

#### 1.1 链接

```markdown
1、静态链接
	程序开始之前，就将各个目标模块和所需的库函数链接成一个完整的可执行程序，往后不再拆开
2、装入时动态链接
	目标模块在装入内存的时候，边装入边链接
3、运行时动态链接
	目标模块的链接是程序执行需要的时候才进行链接
```

#### 1.2 装入

```markdown
1、绝对装入（只适用于单道程序环境）
	程序中的逻辑地址就是实际内存地址，直接将程序和数据按逻辑地址装入物理内存中
2、可重定位装入
	根据物理内存的情况，将装入模块装入内存的适当位置，此时逻辑地址不是实际内存地址，而是存在一定的运算。但是作业装入内存时，必须给它分配全部的内存空间，若没有足够的内存空间，则不能装入该作业。
3、动态运行时装入
	按照逻辑地址就是实际内存地址装入内存，将相对地址转换为绝对地址推迟到程序真正执行的时候才进行，从而实现了将程序分配到不连续的存储区中。
```

### 2、地址重定位

```markdown
装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位
```

### 3、内存保护

```markdown
内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响
```

#### 3.1 CPU中设置一对上、下限寄存器实现保护

```markdown
上、下限寄存器用来存放用户作业在主存中的下限和上限地址，当CPU要访问某个地址的时候，分别和两个寄存器的值相比，判断有无越界
```

#### 3.2 使用重定位寄存器和界地址寄存器实现保护

```markdown
界地址寄存器用来比较是否越界，若没有越界，重地址寄存器的值加上逻辑地址就可以得到物理地址
```

### 4、覆盖与交换

#### 4.1 覆盖

```markdown
由于程序运行时，并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定去，其余部分按调用关系分段。首先将即将要访问的段放入覆盖区，其他的段放在外存，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。
```

#### 4.2 交换

```markdown
把处在等待状态的程序从内存移到辅存，把内存空间腾出来，并把准备好竞争CPU运行的程序从辅存移到内存。
```

## 三、连续分配管理

### 1、单一连续分配

```markdown
内存在此方式下分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区以外的内存空间。这种方式无需进行内存保护。因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其他程序。
```

### 2、固定分区分配

```markdown
将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区的时候，便可以从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。
```

### 3、动态分区分配

```markdown
就是不预先将内存空间划分好，而是进程装入内存的时候，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。

比方说一共内存20MB，进程1进入，占用12MB，进程2进入，占用3MB，进程3进入，需要8MB，发现内存不够，于是等待，当进程1执行完，释放了12MB，此时进程3进入进程1之前的那块内存，还剩余4MB在进程3和进程2之间，若是出现某个进程需要5MB，则对该进程而言，这4MB就是外部碎片。

外部碎片可以用“紧凑”技术克服。

当进程装入或者换出主存的时。若内存中有多个足够大的空闲块，则操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略：

​	1、首次适应算法

​	2、最佳适应算法

​	3、最坏适应算法

​	4、邻近适应算法

```



## 四、非连续分配管理方式

### 1、基本分页存储管理

和固定分区分配差不多，不过分的更细，而且进程同时也被划分成一页一页的

#### 1.1 概念

```markdown
页 —— 进程被分的名称

页号 —— 进程中某个页的编号

页框 —— 物理内存被分的名称

页表 —— 页号与物理地址的映射表

地址结构 —— 区别于页表，结构的第二部分是页内偏移
```

#### 1.2 基本地址变换机构

```markdown
任务就是将逻辑地址转换成内存中的物理地址，这里会有个越界检查，即检查逻辑地址转换到物理地址中是否会越界。

[进程未执行时，页表在内存中的起始地址和页表长度的信息存放在PCB中。进程执行时，放入页表寄存器中]

因为局部性原则（时间局部性：程序中某条指令一旦被执行，不久后该指令可能再次执行；某数据被访问后不久可能会被再次访问。空间局部性：程序访问了某个存储单元，不久后其附近的存储单元也将被访问），所以在逻辑地址转换成物理地址，访问页表之前，设置一个快速页表，记录最近使用的页表信息，这样可以直接从快表中获取物理地址，从而加快访问速度。
```

### 2、基本分段存储管理

```markdown
分段的这个段，指的是进程中的程序段，即划分标准是按照用户进程中的自然段。比方说，用户进程由主程序、两个子程序、栈和一段数据组成，于是就讲这个用户进程划分为5段。

地址转换，也是采用了映射的方式，不过段表的结构为：段号 + 段长 + 该段主存地址 ，即比分页的页表多了一个长度，因为段的长度是由程序本身决定的，不受控制。其余和分页差不多，不过多赘述。
```

### 3、段页式管理

```markdown
就是分页和分段的结合体。

段页式系统的逻辑地址结构： 段号 + 页号 + 页内偏移量。

一个进程中，段表只有一个，而页表可能有多个。

进行地址转换时，首先通过段表查到页表地址，然后通过页表找到页框号，最后形成物理地址。
```

## 五、虚拟存储

### 1、虚拟存储器概述

```markdown
在程序执行过程中，当访问的信息不在内存中时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。——这样，系统就好像为用户提供了一个比实际内存大得多的存储器，称之为虚拟存储器。
```

虚拟内存的实现，需要建立在离散分配的内存管理方式的基础上。

有以下三种方式实现：

```markdown
1、请求分页存储 —— 一个作业运行之前，不要求全部一次性调入内存中
2、请求分段存储
3、请求段页式存储
```

不管哪种实现方式，都需要硬件支持：

```markdown
1、一定容量的内存和外存
2、页表机制（或段表机制），作为主要的数据结构
3、中断机制，当用户程序要访问的部分尚未调入内存时，则产生中断
4、地址变换机构，逻辑地址到物理地址的变换
```

### 2、页面置换算法

进程运行时，若其访问的页面不在内存中而需要将其调入，但内存中已经没有空闲空间时，就需要从内存中调入一页程序或者数据，送入磁盘的对换区。——选择调出页面的算法，即页面置换算法。

```markdown
1、最佳置换算法
2、先进先出页面置换算法
3、最近最久未使用置换算法
4、时钟置换算法
```

