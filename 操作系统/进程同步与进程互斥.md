# 进程同步与进程互斥

## 一、概述

### 1、什么是进程同步

要让各并发进程按要求有序地推进。

——》是一种直接制约关系。（协调进程的工作次序而产生的制约关系）

### 2、什么是进程互斥

就是字面意思

### 3、补充

#### 3.1 什么是临界资源

一个时间段内只允许一个进程使用的资源称为临界资源

#### 3.2 互斥访问临界资源，要遵循的原则

```markdown
1、空闲让进
2、忙则等待
3、有限等待 ——》防止饥饿
4、让权等待 ——》防止忙等待（进程不能进入到临界区，总不能边占用CPU边等待吧）
```

逻辑四区：进入区、临时区、退出区、剩余区

## 二、进程互斥的软件实现方法

### 1、单标志法

解释一下：现在有两个进程，不妨称作进程a和进程b。当进程a访问结束后，某标识位改变，赋予另一个进程进入临界区的权限。要是进程a没有访问完，进程a压根就不存在，那么进程b也不会进入临界区，只会卡在进入区。

比方说：

```c
int turn = 0;

P0:
while (turn != 0);
critical section;
turn = 1;
remainder section;

P1:
while (turn != 1);
critical section;
turn = 0;
remainder section;
```

### 2、双标志（先检查）法

比如说：

```c
bool flag[2];
flag[0] = false;
flag[1] = false;

P0:
while (flag[0]);//检查
flag[0] = true;//上锁
critical section;
flag[0] = false;
remainder section;

P1:
while (flag[0]);//检查
flag[1] = true;//上锁
critical section;
flag[1] = false;
remaider section;
```

进程的异步性会导致两个进程同时进入临界区——》原因：进入区的“检查”、“上锁”两个处理不是原子操作，“检查”后，“上锁”前，可能会发生进程的切换。

### 3、双标志后检查法

可能会发生饥饿现象，原因也是由于“上锁”（该操作在前）、“检查”不是原子操作。

### 4、Peterson算法

没有遵循让权等待，但比上面的三个都要好

## 三、信号量机制

信号量，不是一个boolean类型的量，而是表示某种资源的数量。信号量的操作只有三种，即初始化、P操作、V操作。根据信号量的数据结构的不同，可以分成两种：

### 1、整型信号量

这里的信号量就是一个整型。用这种信号量可能会出现忙等。比如：

```c
int S = 0;

void wait(int S) {
  while (s <= 0);
  s = s - 1;
}//wait操作就是P操作，就是资源数量减少1个。相当于进入区。

void signal(int S) {
  S = S + 1;
}//signal操作就是V操作，就是资源数量加上1个。相当于退出区。
```

### 2、记录型信号量

——》克服了忙等

```c
typedef struct {
  int value;//剩余资源数
  struct process *L;//等待队列。就是当资源数量小于0的时候，就会放在等待队列
} semaphore;

void wait(semaphore S) {
  S.value--;
  if (S.value < 0) {
    /*
    若剩余资源数不够，使用block原语使进程从运行态进入到阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中
    */
    block(S.L);
  }
}

void signal(semaphore S) {
  S.value++;
  if (S.value <= 0) {
    /*
    释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变成就绪态
    */
    wakeup(S.L);
  }
}
```

## 四、信号量机制的实现

### 1、进程互斥

semaphore = 1;

### 2、进程同步

semaphore = 0;

注意：”前“操作之后执行V(S)，“后”操作之前执行P(S)

比如：现假设代码4依赖于代码1、2的结果，即P1进程必须先执行，然后再执行P2进程

```c
semaphore = 0;

P1() {
  代码1;
  代码2;
  V(S);
  代码3;
}

P2() {
  P(S);
  代码4;
  代码5;
  代码6;
}
```

## 五、生产者-消费者问题

```c
semaphore mutex = 1;//互斥信号量——缓冲区是临界资源，比方说生产者往缓冲区添加位置c处添加一个商品，同时另一个生产者也往位置c处添加一个商品，那么之前生产者的商品就会被覆盖
semaphore empty = n;//同步信号量
semaphore full = 0;//同步信号量

producer() {
  while(1) {
    生产一个产品;
    P(empty);
    P(mutex);
    产品放入缓冲区;
    V(mutex);
    V(full);
  }
}

consumer() {
  while(1) {
    P(full);
    P(mutex);
    从缓冲区取出产品;
    V(mutex);
    V(empty);
    使用产品;
  }
}
```

这种分析信号量同步或者互斥的题目，还有很多。还有一个哲学家进餐问题。就是5个哲学家，只有5只筷子。