# 二分算法

## 一、题根——力扣第704题

### 1、题目

```markdown
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例 2:
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
 
提示：
你可以假设 nums 中的所有元素是不重复的。
n 将在 [1, 10000]之间。
nums 的每个元素都将在 [-9999, 9999]之间。
```

### 2、两种代码

#### 2.1 两侧闭区间，即left = 0，right = nums.length - 1

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int mid;

        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
}
```

#### 2.2 左闭右开区间，即left = 0，right = nums.length

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length;
        int mid;

        while (left < right) {
            mid = left + ((right - left) >> 1);
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return -1;
    }
}
```

### 3、解释

#### 3.1 两侧闭区间

```markdown
即 left = 0, right = nums.length - 1;

	这样的话，循环条件则为 left <= right，因为left == right是有意义（可以取到）的。
	
	更新条件：left = mid + 1;
					right = mid - 1;
					因为此时已经保证了 nums[mid] 和给定的 target 不相当了，是可以加1的，而且循环条件保证了不会数组越界
```

#### 3.2 左闭右开区间

```markdown
即 left = 0, right = nums.length;

	这样的话，循环条件则为 left < right，因为left == right是没有意义的，比方说：
		target比升序数组最右侧的数字还要大，如果是 "<=" 的话，最后的循环条件执行的是 left == right，但是 nums[right] 是不存在的，数组越界了。
	更新条件：left = mid + 1;左侧是闭区间，保证一种可以取到的状态
					right = mid;右侧是开区间，保证一种取不到的状态
```

