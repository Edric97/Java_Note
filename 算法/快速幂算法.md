## 快速幂算法

这个算法，听名字高大上，其实很简单。

——比方说，要计算2的100次方，一般会使用下面的代码：

```java
a = a * 2;
```

 这样的话，要计算100次。很明显，时间复杂度是O(N)。这就很慢了。

但是`2^100 <=> (2^2)^50`，后面的就只要计算50次了。

```
2^100 <=> 2^2^50 <=> 2^2^2^25 <=> 2^2^2
```

写到这里，其实思路已经出来了，就是不断的变成原来底数的平方。直到幂变成1



上面是一般的情况，矩阵的快速幂也是一样的。贴一段代码，就可以体会到了。

```java
	public int[][] pow(int[][] a, int n) {
        int[][] ret = {{1, 0}, {0, 1}};
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, a);
            }
            n >>= 1;
            a = multiply(a, a);
        }
        return ret;
    }

    public int[][] multiply(int[][] a, int[][] b) {
        int[][] c = new int[2][2];
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                c[i][j] = (int) (((long) a[i][0] * b[0][j] + (long) a[i][1] * b[1][j]) % MOD);
            }
        }
        return c;
    }
```

解释一下，上面的`(n & 1) == 1`，是与运算，n只要为奇数，就等于1。

而`n >>= 1`等价于`n /= 2`，效率要比后者高，所以用位运算。
