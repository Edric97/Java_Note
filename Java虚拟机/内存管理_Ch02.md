# Java虚拟机

## 一、概述

### 1、什么是java虚拟机？

操作系统是连接软件和硬件的接口，java虚拟机就是虚拟的操作系统，将java在前端编译得到的.class字节码文件，解释成为硬件（CPU）可以理解的二进制文件，从而成为java（软件）和硬件沟通的桥梁。

——不同于C，C++等编译型语言是编译完直接就生成CPU可以理解的二进制文件，java（前端）编译（语义分析等工作）得到的是.class字节码文件，需要Java虚拟机进行解释。

## 二、JVM内存管理

### 1、概述

JVM——Java Virtual Machine，即Java虚拟机——在后端编译成二进制文件，是操作系统上的一个进程。在运行期间，管理着实在的硬件上的内存。我们把这个运行时的内存，人为的分为：线程私有的程序计数器、Java虚拟机栈、本地方法栈，线程公有的堆、方法区。统称为运行时数据区。

### 2、Java虚拟机运行时数据区

#### 2.1 线程私有

##### 2.1.1 程序计数器

作用：字节码解释器工作的时候，通过改变程序计数器的值来选取下一条需要执行的字节码指令。

具体来说主要有：

​	1、控制循环

​	2、控制跳转

​	3、控制分支

​	4、异常处理

​	5、线程恢复——因为Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来执行的。所以各个线程需要记住上次执行到的地方，这个信息就存储在程序计数器中，也解释了程序计数器是线程私有的。

——ps：程序计数器占内存的空间很小，几乎可以忽略不计。

##### 2.1.2 Java虚拟机栈

作用：Java程序中的Java编写的方法只要被执行了，JVM都会同步创建一个栈帧放在Java虚拟机栈中。而栈帧中，又存储着局部变量表、方法出口等信息

Java虚拟机栈描述的是Java方法执行的线程内存模型。听名字就知道了，方法（栈帧）是以栈的数据结构存放的（First In Last Out）。

——栈帧中最主要的，一般指的是局部变量表。局部变量表中存放着基本数据类型、对象引用、returnAdress类型，

##### 2.1.3 本地方法栈

作用：Java中的native方法，以栈帧的形式存放在这里。同样栈帧存放着局部变量表、方法出口等信息。

解释——native方法，指的是Java调用非Java代码的接口。一般都是底层方法。

——————》注释：有的虚拟机是不区分Java虚拟机栈和本地方法栈的，比方说HotSpot虚拟机（最广泛的虚拟机）。

#### 2.2 线程公有

##### 2.2.1 堆

作用：存放对象实例

堆空间也是Java虚拟机运行时数据区中占内存最大的区域。同时，它还是由垃圾收集器管理的内存区域。

HotSpot要求任何对象的大小必须是8字节的整数倍。

——对象的创建：

1、首先不是分配内存，而是去检查字节码new指令是否能在常量池中定位到类的符号引用，并检查引用代表的类是否被加载、解析和初始化过。若没有加载过，则执行类的加载。

2、分配内存。在堆空间中划分出一块指定大小的内存块。（倘若在物理内存上，被占用的和没使用的内存，是整齐分开，说明垃圾收集器是带有空间压缩管理的，这个时候，在被占用和没占用的内存之间，有个指针，那么分配内存的时候，指针移动对象内存大小相等的距离。要是不是整齐分开的，虚拟机就会维护一个列表，记录哪些区域是空闲的，哪些是被占用的，从而解决分配内存的问题）（这里还有一个高并发的问题，即给对象a分配内存的时候，指针还没有移动，对象b创建了，并分配内存移动指针了。那么这里有两种解决办法：详见P49上半部分）

3、虚拟机将分配到的内存空间都初始化为0。——保证了对象的实例字段，即使不赋初值，也可以直接使用，使程序能访问到这些字段的数据类型所对应的零值。

4、设置对象头——由两部分组成：

​	——》存储对象自身的运行时数据，比如哈希码等，64位的虚拟机中分配有64个比特。

​	——》类型指针，Java虚拟机通过该指针来确定这个对象是哪个类的实例，优点是速度快。（这个不是所有的虚拟机都会有，要是没有的话，堆空间会维护一个句柄区域，存放对象的地址和方法区中类的地址，优点是稳定，因为对象很可能就被垃圾回收了）

5、设置实例数据

6、对齐填充——因为HotSpot要求任何对象的大小必须是8字节的整数倍，所以有的对象不满足，就会填充几位，充当占位符。当然要是正好满足大小是8字节的整数倍，那就不需要这一步了。

##### 2.2.2 方法区

作用：存放Class文件，即被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存（即使编译器：Java代码在不同的平台——（比方说操作系统不同，计算机硬件不同）上运行的时候，实时的将代码编译成目标机器上的机器码，即实现了write once, run anywhere）。

##### 2.2.3 运行时常量池

是方法区的一部分，存放的是编译期间生成的各种字面量和符号引用。

### 3、应用

#### 3.1 OutOfMemoryError

​	1、疯狂生成对象，会造成堆内存溢出OOM。——HotSpot可控制内存最大值

​	2、单线程情况：线程申请栈空间，但是栈空间没那么大，或者动态扩展栈内存也不行，会造成OOM。要是申请栈空间成功了，但是疯狂造方法，就会有StackOverFlow。

​			多线程情况：操作系统给每个进程分配的内存有限制的，减去堆空间、方法区空间，忽略程序计数器，再理想化的去掉直接内存和虚拟机进程本身消耗的内存，就剩下虚拟机栈和本地方法栈来分配内存了，要是每个线程分配到的栈内存越大的话，可以建立的线程数量也就变少了。——解决办法：减少线程数量或者更换64位虚拟机，不能减少线程的话，可以减少最大堆和减少栈容量来换取更多的线程。

​	3、疯狂造类，会造成方法区内存溢出OOM。——HotSpot可控制内存最大值



